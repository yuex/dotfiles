" Name:         Vim Configuration of yuex
" Language:     vimscript
" Maintainer:   yuex <yuecn41@gmail.com>
" Source:       http://github.com/yuex/dotfiles

" vundle {{{
    set nocompatible
    filetype off
    set rtp+=~/.vim/bundle/Vundle.vim
    call vundle#begin()

    Plugin 'gmarik/Vundle.vim'
" interface {{{
    Plugin 'Shougo/unite.vim'
    Plugin 'Shougo/unite-help'
    Plugin 'Shougo/vimproc'
    Plugin 'Shougo/neomru.vim'
    " Plugin 'kien/ctrlp.vim'
    Plugin 'scrooloose/nerdtree'
    Plugin 'jistr/vim-nerdtree-tabs'
    Plugin 'project.tar.gz'
    Plugin 'sessionman.vim'
    Plugin 'Lokaltog/vim-powerline'
" }}}
" general {{{
    Plugin 'Raimondi/delimitMate'
    Plugin 'tpope/vim-surround'
    Plugin 'tpope/vim-unimpaired'
    Plugin 'kana/vim-textobj-user'
    Plugin 'mbbill/undotree'
    "Plugin 'YankRing.vim'
    Plugin 'godlygeek/tabular'
    Plugin 'Lokaltog/vim-easymotion'
    " Plugin 'junegunn/vader.vim'
    Plugin 'matchit.zip'
    Plugin 'altercation/vim-colors-solarized'
    " Plugin 'tomasr/molokai'
    Plugin 'mileszs/ack.vim'
    Plugin 'kshenoy/vim-signature'
" }}}
" programming {{{
    " git integration
    Plugin 'tpope/vim-fugitive'
    Plugin 'tpope/vim-sleuth'
    Plugin 'airblade/vim-gitgutter'
    " automatic syntax checker
    Plugin 'hynek/vim-python-pep8-indent'
    Plugin 'yuex/vim-autopep8'
    Plugin 'scrooloose/syntastic'
    Plugin 'scrooloose/nerdcommenter'
    " Plugin 'tpope/vim-commentary'
    Plugin 'majutsushi/tagbar'
    Plugin 'Yggdroot/indentLine'
    Plugin 'a.vim'
    Plugin 'Valloric/YouCompleteMe'
    Plugin 'Shougo/neocomplcache'
    Plugin 'sukima/xmledit'
    Plugin 'Glench/Vim-Jinja2-Syntax'
    Plugin 'alvan/vim-closetag'
    Plugin 'merijn/haskellFoldIndent'
    " Plugin 'Shougo/neosnippet'
    " Plugin 'snipMate'
"}}}
" notetaking {{{
    Plugin 'DrawIt'
    Plugin 'mtth/scratch.vim'
    Plugin 'mrtazz/simplenote.vim'
    Plugin 'jszakmeister/rst2ctags'
    Plugin 'Rykka/riv.vim'
    Plugin 'VOoM'
    Plugin 'jszakmeister/markdown2ctags'
    Plugin 'plasticboy/vim-markdown'
    " Plugin 'yuex/vim-markdown'
    Plugin 'utl.vim'
" }}}

    call vundle#end()
    filetype plugin indent on
    function! PluginInstalled(plugin,...) "{{{
    " PluginInstalled("plugin name")
    " PluginInstalled("plugin name",g:_bundle_name)
    " return 1 or 0
    " if g:_bundle_name doesn't exist, create it
    if !exists("g:_bundle_name")
        let g:_bundle_name = map(copy(g:vundle#bundles), 'v:val.name')
    endif
    if a:0 == 0
        let installed = g:_bundle_name
    else
        let installed = a:1
    endif
    if match(installed, a:plugin) >= 0
        return 1
    endif
    return 0
    endfun " }}}
" }}}
" general options {{{
" editing {{{
    set autowrite
    set virtualedit=onemore
    set formatoptions+=mM
" }}}
" word {{{
    "set spell spelllang=en
    "set dictionary=/usr/local/plan9/lib/words
    "set complete-=k complete+=k
" }}}
" encoding {{{
    set encoding=utf-8
    set fileencodings=ucs-bom,utf-8,default,chinese
" }}}
" ruler and status line {{{
    set ruler
    set number
    set showcmd
    set showmode
    set cursorline  " hightlight current line
    set laststatus=2
    set wildmenu
" }}}
" search {{{
    set hlsearch    " disable with :nohl
    set ignorecase  " dont differ between case
    set smartcase   " override ignorecase when uppercase occurs
    set incsearch   " incremental search
    set wrapscan    " wrapscan = wrap to top when reach end
" }}}
" screen scroll {{{
    set scrolljump=5        " lines to scroll when cursor leaves screen
    set scrolloff=3        " minimum lines to keep around the cursor
" }}}
" indent {{{
    "set nowrap
    set autoindent
    set shiftround
    "set smartindent
    set shiftwidth=4
    set tabstop=4
    set softtabstop=4
    set expandtab
" }}}
" listchars {{{
    set list
    set listchars=tab:×•,trail:•,extends:#,nbsp:•
" }}}
" linewrap {{{
    " using gq
    set textwidth=79
    if exists('+colorcolumn')
        set colorcolumn=80
    else
        au BufWinEnter * let w:m2=matchadd('ErrorMsg', '\%>80v.\+', -1)
    endif
" }}}
" fold {{{
    set foldmethod=indent
    set foldopen+=insert
    for lvl in range(0,9)
        exec "nnoremap <unique> <Leader>z".lvl." :set foldlevel=".lvl."<CR>"
    endfor
    nnoremap <unique> <M-o> @=foldclosed(".")>0?"zv":"zc"<CR>
    nnoremap <unique> z] ]z
    nnoremap <unique> z[ [z
" }}}
" color scheme {{{
    set bg=dark
    "set t_Co=256
    syntax on
    " solarized needs termianl palette configured properly
    " checkout
    colorscheme solarized
    "colorscheme molokai
    "let g:solarized_termcolors=256
    "let g:solarized_termtrans=1
    let g:solarized_contrast="high"
    let g:solarized_visibility="high"
" }}}
" iskeyword {{{
    " I wanna my iskeyword
    function! GiveMeKeyword()
        if exists('b:give_me_keyword') && !b:give_me_keyword
            return
        endif
        set iskeyword&
        set iskeyword-=_
    endfunc
    autocmd Filetype help let b:give_me_keyword=0
    call GiveMeKeyword()
" }}}
" leader {{{
    let mapleader = ';'
    let maplocalleader = ','
" }}}
" meta key {{{
" vim hacks fix meta-keys which generate <Esc>a .. <Esc>z
    for i in range(char2nr('a'), char2nr('z'))
        let i = nr2char(i)
        exec "set <M-".i.">=\<Esc>".i
        exec "inoremap \<Esc>".i." <M-".i.">"
    endfor
    for i in range(char2nr('0'), char2nr('9'))
        let i = nr2char(i)
        exec "set <M-".i.">=\<Esc>".i
        exec "inoremap \<Esc>".i." <M-".i.">"
    endfor
" }}}
" }}}
" autocommand {{{
    " set filetype for *.conf
    "autocmd BufRead,BufNewFile *.conf setfiletype conf
" autocmd executable {{{
    let g:_executable_env = '#!/usr/bin/env ' "{{{
    let g:_executable = {
                \'python': 'python',
                \'ruby': 'ruby',
                \'sh': 'sh',
                \'racket': ['racket', '#lang racket'],
                \'scheme': ['racket', '#lang racket'],
                \} "}}}
    for k in keys(g:_executable) "{{{
        let v = g:_executable[k]
        if type(v) == type('')
            let g:_executable[k] = g:_executable_env . v
        elseif type(v) == type([])
            let v[0] = g:_executable_env . v[0]
            let g:_executable[k] = v
        endif
        unlet v
    endfor "}}}
    function! AddHeader() "{{{
        if !exists('g:_executable')
                    \|| !has_key(g:_executable, &ft)
                    \|| match(getline(1),'#!', 0) >= 0
            return
        endif

        let header = g:_executable[&ft]
        if type(header) == type('') || type(header) == type([])
            call append(0, header)
        endif
    endfunc "}}}
    function! AddXPerm() "{{{
        if !exists('g:_executable') || !has_key(g:_executable, &ft)
            return
        endif

        let ft_save = &ft
        !chmod a+x %
        edit!
        doautocmd Syntax
        redraw!
    endfunc "}}}
    autocmd FileType * call AddHeader()
    autocmd BufWritePost * call AddXPerm()
" }}}
" autocmd make {{{
    " quick :make
    nnoremap <unique><silent> <F5> :make!<CR>
    " hack for python2 on archlinux
    autocmd FileType python set makeprg=python\ %
    autocmd FileType ruby set makeprg=ruby\ %
    autocmd FileType tcl set makeprg=tclsh\ %
    autocmd FileType sh set makeprg=bash\ %
    autocmd FileType lisp set makeprg=clisp\ %
    autocmd FileType tex set makeprg=pdflatex\ %
    autocmd FileType c set makeprg=gcc\ -Wall\ -o%<\ %;./%<
    autocmd FileType haskell set makeprg=runhaskell\ %
    autocmd Filetype go set makeprg=go\ run\ %
" }}}
" autocmd indent {{{
    autocmd FileType python setlocal tabstop=4 shiftwidth=4 softtabstop=4
    autocmd FileType java setlocal tabstop=4 shiftwidth=4 softtabstop=4
    autocmd FileType c,cpp setlocal tabstop=2 shiftwidth=2 softtabstop=2
    autocmd FileType yaml setlocal tabstop=2 shiftwidth=2 softtabstop=2
    autocmd FileType xml,html,css,htmldjango
                \ setlocal tabstop=2 shiftwidth=2 softtabstop=2
    autocmd FileType make setlocal noexpandtab
" }}}
" }}}
" smart mode, keymappings {{{
" cd and sudo {{{
    cnoremap <unique> cwd lcd %:p:h
    cnoremap <unique> cd. lcd %:p:h
    " when u forget to sudo.. really write the file
    cnoremap <unique> w!! w !sudo tee % >/dev/null
" }}}
" smartquit {{{
    "nnoremap <C-c> :confirm q<CR>
    "nnoremap <C-c> :q<CR>
    " function SmartQuit()  {{{
    function SmartQuit()
        if !&modified
            exec "quit"
        else
            redraw
            echohl WarningMsg
            echo "Buffer changed! [^W]w [^S]x [^B^N]q!: "
            echohl None

            let cmd = ""
            let ret = nr2char(getchar())

            if ret == "\<C-b>" || ret == "\<C-n>"
                " BOOM! NUKE!
                let cmd = "q!"
            elseif ret == "\<C-w>"
                "let cmd = "w"
                let cmd = "call SmartWrite('w')"
            elseif ret == "\<C-s>"
                "let cmd = "x"
                let cmd = "call SmartWrite('x')"
            endif

            redraw
            if !empty(cmd)
                exec cmd
            endif
        endif
    endfunction
    " }}}
    nnoremap <unique> <C-c> :call SmartQuit()<CR>
    " make C-c to trigger InsertLeave to make ^V insert at head working
    inoremap <unique> <C-c> <Esc>
    "vnoremap <unique> <C-c> <Esc>
    "cnoremap <unique> <C-c> <Esc>
" }}}
" tabpage {{{
    " XXX: use <kHome>/<kEnd> to hack around <M-Home>/<M-End>.  although <M-X>
    " mapping with these two keys still won't work, <Esc><X> do.
    nnoremap <unique> <Esc><Home>      :tabfirst<CR>
    nnoremap <unique> <Esc><kHome>     :tabfirst<CR>
    nnoremap <unique> <Esc><End>       :tablast<CR>
    nnoremap <unique> <Esc><kEnd>      :tablast<CR>

    nnoremap <unique> <Esc><PageUp>    :tabmove -1<CR>
    nnoremap <unique> <Esc><kPageUp>   :tabmove -1<CR>
    nnoremap <unique> <Esc><PageDown>  :tabmove +1<CR>
    nnoremap <unique> <Esc><kPageDown> :tabmove +1<CR>

    nnoremap <unique> <silent> <Esc><Left>  :tabprevious<CR>
    nnoremap <unique> <silent> <Esc><Right> :tabnext<CR>
    nnoremap <unique> <silent> <Esc><Up>    :tabedit<Space>
    nnoremap <unique> <silent> <Esc><Down>  :tabclose

    " move to tab #1-#9, #0 is last"
    nnoremap <unique> <C-g>0 :tablast<CR>
    inoremap <unique> <C-g>0 <C-o>:tablast<CR>
    let c = '1'
    while c <= '9'
        exec "nnoremap <unique> <C-g>".c." :tabnext ".c."<CR>"
        exec "inoremap <unique> <C-g>".c." <Esc>:tabnext ".c."<CR>"
        let c = nr2char(1+char2nr(c))
    endw
" }}}
" buffer {{{
    nnoremap <unique> <silent> <C-g><C-u>   :buffers<CR>
    nnoremap <unique> <silent> <C-g><C-p>   :bprevious<CR>
    nnoremap <unique> <silent> <C-g><C-n>   :bnext<CR>
    "nnoremap <unique> <silent> <PageUp>     :bprevious<CR>
    "nnoremap <unique> <silent> <PageDown>   :bnext<CR>

    inoremap <unique> <silent> <C-g><C-p>   <Esc>:bprevious<CR>
    inoremap <unique> <silent> <C-g><C-n>   <Esc>:bnext<CR>
    "inoremap <unique> <silent> <PageUp>     <Esc>:bprevious<CR>
    "inoremap <unique> <silent> <PageDown>   <Esc>:bnext<CR>

    nnoremap <unique> <M-0> :blast<CR>
    inoremap <unique> <M-0> <C-o>:blast<CR>
    let c = '1'
    while c <= '9'
        exec "nnoremap <unique> <M-".c."> :buffer ".c."<CR>"
        exec "inoremap <unique> <M-".c."> <Esc>:buffer ".c."<CR>"
        let c = nr2char(1+char2nr(c))
    endw
" }}}
" toggle options {{{
    inoremap <unique> <M-m> <C-o>:setlocal number!<CR>
    nnoremap <unique> <M-m> :setlocal number!<CR>
    inoremap <unique> <M-s> <C-o>:setlocal hlsearch!<CR>
    nnoremap <unique> <M-s> :setlocal hlsearch!<CR>
" }}}
" jkTF motion {{{
    " go as u see
    noremap <unique> j gj
    noremap <unique> k gk
    map <unique> gt T
    map <unique> gf F
" }}}
" quickmode {{{
    function SmartMove(moveToNext, moveToEnd, ...) "{{{
        " if line number changed, use moveToEnd, otherwise use moveToNext
        " will ensure cursor get changed to avoid deadlock
        " a:operator to deal with visualmode
        " a:withLine to confine the movement within one line
        let l:operator = ''
        let l:withinLine = 0
        if a:0 > 0
            let l:operator = a:1
        endif
        if a:0 > 1
            let l:withinLine = a:2
        endif
        let l:prev_pos = getpos('.')
        let [_,l:prev_line,l:prev_col,_] = l:prev_pos

        exec "normal! " . a:moveToNext

        let l:post_line = line('.')
        call setpos('.', l:prev_pos)

        if l:post_line ==# l:prev_line
            exec "normal! " . l:operator . a:moveToNext
        else
            if l:withinLine
                exec "normal! " . l:operator . a:moveToEnd
            elseif (l:post_line <=# l:prev_line && col('.') ==# 1)
                \|| (l:post_line >=# l:prev_line && col('.') >=# len(getline('.')))
                exec "normal! " . l:operator . a:moveToNext
            else
                exec "normal! " . l:operator . a:moveToEnd
            endif
        endif
    endfunc " }}}
    func SmartWrite(...) "{{{
        let cmd = 'w'
        if a:0 > 0
            let cmd = a:1
        endif
        if empty(bufname('%'))
            call WriteWithName(cmd)
        else
            exec cmd
        endif
    endfunction

    func WriteWithName(cmd)
        " :h input() and :h command-completion
        call inputsave()

        let filename = input(':'.a:cmd.' ', '', 'file')
        let cmds = [a:cmd, filename]
        if !empty(glob(filename))
            redraw
            echohl WarningMsg
            echo '"'.filename.'" existed. Force '.a:cmd.' [!] ? [Y/n] '
            echohl None

            let choice = nr2char(getchar())
            if choice == "\<CR>" || choice ==? 'y'
                call CmdExecute(cmds, 1)
            endif
        else
            call CmdExecute(cmds, 0)
        endif

        call inputrestore()
    endfunction "}}}
    func CmdExecute(cmds, force) "{{{
        if a:force
            let cmd = a:cmds[0].'! '.join(a:cmds[1:])
        else
            let cmd = join(a:cmds)
        endif

        if exists('cmd')
            exec cmd
        endif
    endfunction

    func SmartWrite2()
        let cmd = 'w '
        try
            exec cmd
        catch /^Vim(write):E32:/
            "catch Vim(write):E32:No file name
            "echo v:exception
            call SmartWriteWithName()
        endtry
    endfunction " }}}
    "nnoremap <unique> <Esc><Leader><M-w> :w !sudo tee % >/dev/null
    "nnoremap <unique> <Esc><Leader><Esc><Leader> :
    noremap \ ;
    noremap <C-\> ,
    noremap <Esc><Leader> :
    nnoremap <unique> <Esc><Leader><Esc><Leader> :
    nnoremap <unique> <Esc><Leader><M-w>  :call SmartWrite()<CR>
    nnoremap <unique> <Esc><Leader><M-e>  :w<Space>
    nnoremap <unique> <Esc><Leader><M-q>  :x<CR>
    " quickinsert inoremap {{{
    " it seems <C-Left> and <C-Right> in insert mode
    let g:omni_sql_no_default_maps=1
    inoremap <Esc><Leader> <C-o>:
    inoremap <unique> <Esc><Leader><Esc><Leader> <C-o>:
    inoremap <unique> <Esc><Leader><M-w> <C-o>:call SmartWrite()<CR>
    inoremap <unique> <C-a> <C-o>^
    inoremap <unique> <C-e> <End>
    inoremap <unique> <C-h> <Left>
    inoremap <unique> <C-l> <Right>
    inoremap <unique> <Esc><C-h> <C-o>:call SmartMove('b','0')<CR>
    inoremap <unique> <Esc><C-l> <C-o>:call SmartMove('w','w')<CR>
    inoremap <unique> <M-b> <C-o>:call SmartMove('b','0')<CR>
    inoremap <unique> <M-f> <C-o>:call SmartMove('w','w')<CR>

    inoremap <unique> <C-j> <C-o>g<Down>
    inoremap <unique> <C-k> <C-o>g<Up>
    inoremap <unique> <M-e> <C-o>e<Right>
    inoremap <unique> <Esc><C-j> <C-o>4j
    inoremap <unique> <Esc><C-k> <C-o>4k

    inoremap <unique> <C-u> <C-o>d0
    inoremap <unique> <M-u> <C-o>d$
    inoremap <unique> <Esc><C-u> <C-o>d^
    "inoremap <unique> <Esc><C-k> <C-o>d$
    inoremap <unique> <C-w> <C-o>:call SmartMove('b','0','d')<CR>
    inoremap <unique> <M-d> <C-o>:call SmartMove('e','$','d')<CR>
    inoremap <unique> <M-w> <C-o>:call SmartMove('e','$','d')<CR>
    inoremap <unique> <C-y> <C-r>-
    inoremap <unique> <C-s> <C-o>d
    inoremap <unique> <C-s>u <C-o>u
    inoremap <unique> <C-t> <C-o>~
    inoremap <unique> <M-t> <Left><C-o>~<Left>

    inoremap <unique> <M-a> <C-o><C-a>
    inoremap <unique> <M-x> <C-o><C-x>

    inoremap <unique> <M-v> <C-o>v
    " }}}
    " quickcmd {{{
    "cnoremap <C-o> <C-f>, set cedit=
    set cedit=<C-o>
    set cmdwinheight=3
    noremap : :<C-o><C-c>

    cnoremap <unique> <C-a> <C-o>^<C-c>
    cnoremap <unique> <C-e> <End>
    cnoremap <unique> <C-h> <Left>
    cnoremap <unique> <C-l> <Right>
    cnoremap <unique> <Esc><C-h> <C-o>:call SmartMove('B','0','',1)<CR><C-c>
    cnoremap <unique> <Esc><C-l> <C-o>:call SmartMove('W','$','',1)<CR><C-c>
    cnoremap <unique> <M-h> <C-o>:call SmartMove('b','0','',1)<CR><C-c>
    cnoremap <unique> <M-l> <C-o>:call SmartMove('w','$','',1)<CR><C-c>
    " cnoremap <unique> <Esc><C-h> <C-o>B<C-c>
    " cnoremap <unique> <Esc><C-l> <C-o>W<C-c>
    " cnoremap <unique> <M-h> <C-o>b<C-c>
    " cnoremap <unique> <M-l> <C-o>w<C-c>
    "cnoremap <unique> <M-h> <BS>
    "cnoremap <unique> <M-l> <Del>

    cnoremap <unique> <M-n> <Down>
    cnoremap <unique> <M-p> <Up>
    cnoremap <unique> <M-j> <Down>
    cnoremap <unique> <M-k> <Up>
    " noremap! <S-Left> isn't enough for c-mode

    cnoremap <unique> <C-j> <C-n>
    cnoremap <unique> <C-k> <C-p>
    cnoremap <unique> <M-e> <C-o>el<C-c>

    cnoremap <unique> <C-u> <C-o>d0<C-c>
    cnoremap <unique> <M-u> <C-o>d$<C-c>
    cnoremap <unique> <Esc><C-u> <C-o>d^<C-c>
    cnoremap <unique> <Esc><C-k> <C-o>d$<C-c>
    cnoremap <unique> <C-w> <C-o>db<C-c>
    cnoremap <unique> <M-d> <C-o>de<C-c>
    cnoremap <unique> <M-w> <C-o>de<C-c>
    cnoremap <unique> <C-y> <C-r>-
    cnoremap <unique> <C-s> <C-o>d

    cnoremap <unique> <M-a> <C-o><C-a><C-c>
    cnoremap <unique> <M-x> <C-o><C-x><C-c>
    " }}}
    " quicknormal {{{
    noremap <unique> <C-a> ^
    noremap <unique> <C-e> <End>
    "noremap <unique> <M-h> <Left>
    "noremap <unique> <M-l> <Right>
    "noremap <unique> <M-j> g<Down>
    "noremap <unique> <M-k> g<Up>
    noremap <unique> <Esc><C-b> <S-Left>
    noremap <unique> <Esc><C-f> <S-Right>
    noremap <unique> <Esc><C-w> w
    noremap <unique> <Esc><C-e> e
    noremap <unique> <C-j> 4j
    noremap <unique> <C-k> 4k
    noremap <unique> <Esc><C-j> 8j
    noremap <unique> <Esc><C-k> 8k

    nnoremap <unique> <C-h> :call SmartMove('ge','gel')<CR>
    nnoremap <unique> <C-l> :call SmartMove('e','el')<CR>
    nnoremap <unique> <M-b> :<C-u>call SmartMove('ge','gel')<CR>
    nnoremap <unique> <M-f> :<C-u>call SmartMove('e','el')<CR>
    nnoremap <unique> <Esc><C-h> :<C-u>call SmartMove('gE','gEl')<CR>
    nnoremap <unique> <Esc><C-l> :<C-u>call SmartMove('E','El')<CR>

    vnoremap <unique> <C-h> <Esc>:<C-u>call SmartMove('ge','gel','gv')<CR>
    vnoremap <unique> <C-l> <Esc>:<C-u>call SmartMove('e','el','gv')<CR>
    vnoremap <unique> <M-b> <Esc>:<C-u>call SmartMove('ge','gel','gv')<CR>
    vnoremap <unique> <M-f> <Esc>:<C-u>call SmartMove('e','el','gv')<CR>
    vnoremap <unique> <Esc><C-h> <Esc>:<C-u>call SmartMove('gE','gEl','gv')<CR>
    vnoremap <unique> <Esc><C-l> <Esc>:<C-u>call SmartMove('E','El','gv')<CR>

    nnoremap <unique> Y y$

    nnoremap <unique> <Esc><C-a> <C-a>
    nnoremap <unique> <Esc><C-x> <C-x>

    "noremap <unique> <M-h> X
    "noremap <unique> <M-l> x
    " }}}
" }}}
" quick shift {{{
    vnoremap <unique> <Esc>, <gv
    vnoremap <unique> <Esc>. >gv
    vnoremap <unique> < <gv
    vnoremap <unique> > >gv
    " use <c-d> and <c-t> in i-mode to keep cursor's position
    " inoremap <unique> <Esc>, <C-d>
    " inoremap <unique> <Esc>. <C-t>
    " nnoremap <unique> < <<
    " nnoremap <unique> > >>
    inoremap <unique> <Esc>, <C-d>
    inoremap <unique> <Esc>. <C-t>
    nnoremap <unique> <Esc>, <<
    nnoremap <unique> <Esc>. >>
    cnoremap <unique> <Esc>, <C-o>i<C-d><C-c>
    cnoremap <unique> <Esc>. <C-o>i<C-t><C-c>
" }}}
" quicksearch, easysearch {{{
    " function Searchlist() {{{
    " search result to list
    function Searchlist(pattern, flag)
        let @/ = a:pattern
        exec 'lvimgrep /'.a:pattern.'/'.a:flag.' %'
        call QuickfixToggle('l')
    endfun
    " }}}
    " search and visual select (..) and )..( {{{
    " checkout vim-textobj-user
    "for c in add(split('(:),[:],{:},<:>,*:*,-:-,":"',','),"':'")
        "let [s,e] = split(c,':')
        "let switched = 0
        "while 1
            "let s_re = escape(s, '[\^$.*')
            "let e_re = escape(e, ']\^$.*')
            "let i_re = s_re.'\zs[^'.escape(e.s,'^]\').']*\ze'.e_re
            "let a_re = '\zs'.s_re.'[^'.escape(e.s,'^]\').']*'.e_re.'\ze'
            "let mycount = v:count > 1 ? v:count : ''

            "" use \i* and \a* to search for next **
            "" use |i* and |a* to search for prev **
            "" preceding count is supported
            "exec "noremap \\i".s." ".mycount."/".i_re."<CR>"
            "exec 'noremap \|i'.s." ".mycount."?".i_re."<CR>"
            "exec "noremap \\a".s." ".mycount."/".a_re."<CR>"
            "exec 'noremap \|a'.s." ".mycount."?".a_re."<CR>"

            "" self-defined text object
            "" va* and vi* to select between **
            "" I know it's some dirty hacks, but easy to be converted into a
            "" plugin or so. Maybe some time later when I get the mood
            "" it's actually some scripted version of following mappings
            "" vnoremap a* :<C-u>set nows<CR>v?\*<CR>o/\*<CR>:<C-u>set ws<CR>gv
            "" vnoremap i* :<C-u>set nows<CR>v?\*\zs?e+1<CR>o/\ze\*/e-1<CR>:<C-u>set ws<CR>gv
            "exec 'vnoremap a'.s.' '.
                        "\':<C-u>set nows<CR>
                        "\v?'.s_re.'<CR>
                        "\o/'.e_re.'<CR>
                        "\:<C-u>set ws<CR>
                        "\gv'
            "exec 'vnoremap i'.s.' '.
                        "\':<C-u>set nows<CR>
                        "\v?'.s_re.'<CR>l
                        "\o/'.e_re.'<CR>h
                        "\:<C-u>set ws<CR>
                        "\gv'

            "" a simple check to support (:) and ):( automatically
            "" so you don't need to manually put ):( in the for loop
            "if s ==# e || switched
                "break
            "else
                "let [s,e] = [e,s]
                "let switched = 1
            "endif
        "endw
    "endfor
    "for off in split('e:s:b','\zs')
        "exec "vnoremap v".off." //".off."<CR>"
    "endfor
    " }}}
    " visual mode * and # {{{
    " Search for visual selected text, forwards or backwards.
    " visual select text, use * for forwards and # for backwards searching
    " n and N to go next and prev
    " stolen from http://vim.wikia.com/wiki/Search_for_visually_selected_text
    vnoremap <unique><silent> * :<C-U>
      \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
      \gvy/<C-R><C-R>=substitute(
      \escape(@", '/\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
      \gV:call setreg('"', old_reg, old_regtype)<CR>
    vnoremap <unique><silent> # :<C-U>
      \let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
      \gvy?<C-R><C-R>=substitute(
      \escape(@", '?\.*$^~['), '\_s\+', '\\_s\\+', 'g')<CR><CR>
      \gV:call setreg('"', old_reg, old_regtype)<CR>
    " }}}
" }}}"
" quickpaste, quickcopy {{{
    set pastetoggle=<M-p>
    vnoremap <unique> <Esc><C-y> "+y
    nnoremap <unique> <Esc><C-y> "+yy
    " paste before the curor
    nnoremap <unique> <Esc><C-v> "+P
    " paste after the curor, rare case
    inoremap <unique> <Esc><C-v> <C-o>"+P
" }}}
" quick register editing {{{
    function RegisterEdit() "{{{
        let reg = nr2char(getchar())
        if reg !~# '["[:alnum:]-:.%#=*+~_/]'
            echohl WarningMsg
            echo "Wrong Register Name!"
            echohl None
            return
        endif
        call inputsave()
        let content = input('@'.reg.'=')
        call inputrestore()
        call setreg(reg, content)
    endfunc "}}}
    function RegisterEdit2() "{{{
        call inputsave()
        registers
        echo '@'
        let reg = nr2char(getchar())
        if reg !~# '["[:alnum:]-:.%#=*+~_/]'
            redraw!
            echohl WarningMsg
            echo "Wrong Register Name!"
            echohl None
            return
        endif
        redraw!
        " exec 'register '.reg
        echo '"'.reg.'   '.getreg(reg)
        let content = input('@'.reg.' = ')
        call setreg(reg, content)
        call inputrestore()
    endfunc "}}}
    " nnoremap <silent><unique> <Leader>qq :registers<CR>
    nnoremap <silent><unique> <Leader>qq :call RegisterEdit2()<CR>
" }}}
" quickwindow {{{
    "nnoremap <C-w><C-m> :vnew<CR>
    "nnoremap <C-w>m     :vnew<CR>
    noremap <unique> <C-w><C-n>\|     :vnew<CR>
    noremap <unique> <C-w><C-n>_     :new<CR>
    noremap <unique> <C-w>_ <C-w><C-s>
    noremap <unique> <C-w>\| <C-w><C-v>
    noremap <unique> <C-w>== <C-w>=
    noremap <unique> <C-w>=_ <C-w>_
    noremap <unique> <C-w>=\| <C-w>\|

    function! GotoLastWindow()
        if v:count > 0
            exec v:count.'wincmd w'
            return
        endif
        let last = winnr()
        wincmd p
        let curr = winnr()
        if last == curr
            wincmd w
        endif
    endfunc
    noremap <unique> <M-r> <C-w>w
    noremap <unique> <Esc><C-r> <C-w>W
    noremap <unique> <M-w> :call GotoLastWindow()<CR>

    noremap <unique> <C-w>+ 5<C-w>+
    noremap <unique> <C-w>- 5<C-w>-
    noremap <unique> <C-w>< 5<C-w>>
    noremap <unique> <C-w>> 5<C-w><

    "noremap <unique> <C-w>o <C-w>w
    "noremap <unique> <C-w>O <C-w>W
    noremap <unique> <C-w><C-t> <C-w>T
" }}}
" quickfix {{{
    function QuickfixToggle(type) "{{{
    " todo, fixme, and xxx vimgrep
        let flagname = 'b:quickfix_'.a:type.'_opened'
        let cmdopen = a:type.'window'
        let cmdclose = a:type.'close'
        if !exists(flagname)
            exec "let ".flagname." = 0"
        endif
        exec "let flag = ".flagname
        if flag == 0
            " in the cmd invode window
            exec "let ".flagname." = 1 "
            exec cmdopen
            " in the quickfix window
            exec "let ".flagname." = 1 "
        elseif flag == 1
            " in the cmd invode window
            exec "let ".flagname." = 0 "
            exec cmdclose
            " in the quickfix window
            exec "let ".flagname." = 0 "
        endif
    endfunc " }}}
    function QuickfixCompile(type) "{{{
        let flagname = 'b:quickfix_' . a:type . '_compiled'
        if !exists(flagname)
            exec "let " . flagname . " = 0"
        endif
        exec "let flag = " . flagname
        if flag == 1 || &ft ==# 'qf'
            return
        endif
        if flag == 0
            " todo:
            let grep_cmd = 'vimgrep /\v\C(TODO|FIXME|XXX):/ %'
            if a:type ==# 'l'
                let grep_cmd = a:type . grep_cmd
            endif
            try
                exec grep_cmd
            catch
                " e.g., not saved file
                echoerr v:exception
                return
            endtry
            exec "let " . flagname . " = 1"
        endif
    endfunc " }}}
    "nnoremap <unique> <Leader>td :vimgrep /TODO\\|FIXME\\|XXX/ %<CR>
                "\ :call QuickfixToggle('c')<CR>
    "nnoremap <unique> <Leader>ld :lvimgrep /TODO\\|FIXME\\|XXX/ %<CR>
                "\ :call QuickfixToggle('l')<CR>
    nnoremap <unique> <Leader>tt :call QuickfixCompile('c')<CR>
                \ :call QuickfixToggle('c')<CR>
    nnoremap <unique> <Leader>ll :call QuickfixCompile('l')<CR>
                \ :call QuickfixToggle('l')<CR>
    nnoremap <unique> <Leader>tn :cnext<CR>
    nnoremap <unique> <Leader>tp :cprev<CR>
    nnoremap <unique> <Leader>ln :lnext<CR>
    nnoremap <unique> <Leader>lp :lprev<CR>
    nnoremap <unique> <Leader>lo :lopen<CR>
    nnoremap <unique> <Leader>lc :lclose<CR>
" }}}
" smartbinary, smart binary {{{
    function ToggleBinaryMode() "{{{
        if !exists('b:_binary_on')
            let b:_binary_on = 0
        endif
        if !b:_binary_on
            setlocal binary
            exec "%!xxd"
            let b:_binary_on = 1
        else
            exec "%!xxd -r"
            setlocal nobinary
            let b:_binary_on = 0
        endif
    endfunc "}}}
    nnoremap <unique> <Leader>bb :call ToggleBinaryMode()<CR>
" }}}
" strip space at the end of line {{{
    function! AutoSpaceCJK(mode) "{{{
        "let range = "'" . 'A-Z0-9a-z~!@#$%\^&*()_+`-=\[\]{}:;"<>,./?\\|'
        let pat_range = '"'
                    \. "A-Z0-9a-z~!@#$%^&*()=_+`[{}:;". "'<>,./?|"
                    \. "\\-\\]\\\\"
        let pat_no = '[^ ' . pat_range . ']'
        let pat_ya =  '[' . pat_range . ']'

        let range = ''

        if a:mode == 'v' || a:mode ==# ''
            let range = "'<,'>"
        elseif a:mode ==# 'n'
            let range = '.'
        endif

        "echom range
        "echom range_no
        "echom range_ya

        "exec 'substitute/\v\S\zs(' . range_ya . '+)\ze\S/ \1 /g'
        exec range . 'substitute/\v'. pat_no .'\zs(' . pat_ya . ')\ze/ \1/ge'
        exec range . 'substitute/\v\zs('. pat_ya .')\ze' . pat_no . '/\1 /ge'
        redraw!
    endfunc " }}}
    function! SpaceFormat() "{{{
        let praise = "Neat Yo!"
        let trailing_space_replace = '%s/\s\+$//g'
        exec 'retab'
        try
            exec trailing_space_replace
        catch /^Vim\%((\a\+)\)\=:E486/
            echo praise
        endtry
    endfunc "}}}
    "nnoremap <unique> <Leader>fs :retab<CR>:%s/\s\+$//g<CR>
    nnoremap <unique> <Leader>fs :call SpaceFormat()<CR>
    nnoremap <unique> <Leader>fc gg=G
    nnoremap <unique> <Leader>ff :call AutoSpaceCJK('n')<CR>
    vnoremap <unique> <Leader>ff :<C-u>call AutoSpaceCJK(visualmode())<CR>
" }}}
" zz, zt, zb, place current line on screen {{{
    for key in ['z','t','b']
        exec "inoremap <unique> <C-z><C-".key."> <C-o>z".key
    endfor
    for key in ['H','L','M']
        exec "inoremap <unique> <C-z><C-".tolower(key)."> <C-o>".key
    endfor
" }}}
" exec function in insert mode {{{
    " insert mode <C-r>=Funcexec(cmd)
    " used to execute normal commands in insert mode without leaving
    function Funcexec(cmd)
        exec a:cmd
    endfun
" }}}
" poor man's hammer {{{
    "autocmd FileType vimwiki,markdown nnoremap <Leader>hh
    autocmd FileType vimwiki,markdown nnoremap <buffer> <Leader>hh
                \ :silent !pandoc -r markdown -w html "%" > "/tmp/%:t.html"<CR>
                \ :silent !xdg-open "/tmp/%:t.html"<CR>
                \ :redraw!<CR>
    autocmd FileType rst nnoremap <buffer> <Leader>hh
                \ :silent !pandoc -r rst -w html "%" > "/tmp/%:t.html"<CR>
                \ :silent !xdg-open "/tmp/%:t.html"<CR>
                \ :redraw!<CR>
    "nnoremap <unique> <Leader>hh :Hammer<CR>
" }}}
" mottos {{{
    let g:mottos_prompt = "省» "
    noremap <unique><silent> <C-s>
                \ :<C-u>echoh Question
                \\| echo g:mottos_prompt.substitute(system('mottos',&winwidth-strlen(g:mottos_prompt)),'','','')
                \\| echoh None<CR>
" }}}
" }}}
" plugins {{{
if PluginInstalled('unite.vim') "{{{
    let g:unite_source_history_yank_enable=1
    let g:unite_source_history_yank_save_clipboard=1
    function! ChooseFileMode() "{{{
        call inputsave()
        redraw!
        echon 'mode:'
        let char = nr2char(getchar())
        if char ==# 'f'
            exec 'Unite file'
        elseif char ==# 'g'
            exec 'Unite file_rec/git'
        elseif char ==# 'i'
            let path = input('-input=','', 'file')
            exec 'Unite file -input'.path
        elseif char ==# 'a'
            exec 'Unite file_rec/async'
        else
            redraw!
            echohl WarningMsg
            echo "mode unknown"
            echohl None
        endif
        call inputrestore()
    endfunc "}}}
    nnoremap <unique> <Leader>uu :Unite 
    " nnoremap <unique> <Leader>uf :Unite file<CR>
    nnoremap <unique> <Leader>uf :call ChooseFileMode()<CR>
    " nnoremap <unique> <Leader>uss :Unite file -input=
    " nnoremap <unique> <Leader>usa :Unite file_rec/async<CR>
    " nnoremap <unique> <Leader>usg :Unite file_rec/git<CR>
    nnoremap <unique> <Leader>um :Unite neomru/file neomru/directory<CR>

    nnoremap <unique> <Leader>uh :Unite help<CR>
    nnoremap <unique> <Leader>uy :Unite history/yank<CR>
    nnoremap <unique> <Leader>ub :Unite buffer<CR>
    nnoremap <unique> <Leader>ut :Unite tab<CR>
    nnoremap <unique> <Leader>ur :Unite register<CR>
    nnoremap <unique> <Leader>uw :Unite window<CR>
    nnoremap <unique> <Leader>ug :Unite grep:%
    nnoremap <unique> <Leader>uj :Unite jump<CR>
    nnoremap <unique> <Leader>u` :Unite jump<CR>
    nnoremap <unique> <Leader>uc :Unite change<CR>
endif " }}}
if PluginInstalled('vim-surround') "{{{
    " function! del
    " nnoremap ds<Space> F<Space>xf<Space>x
endif " }}}
if PluginInstalled('project.tar.gz') "{{{
    nmap <unique> <M-g> <Plug>ToggleProject
endif " }}}
if PluginInstalled('vim-easymotion') "{{{
    " to have more choice for insert mode eaasymotion
    " for exmaple, <M-o>ge, <M-o>gE
    let g:EasyMotion_leader_key = '<M-v>'
    let g:EasyMotion_keys = 'abcdefghijklmnopqrstuvwxyz'
    let g:EasyMotion_do_shade = 0
    " use easymotion replace vim's default motion
    for key in ['W','B','E',"gE"]
        exec "map ".key." <Plug>(easymotion-".key.")"
    endfor
    for key in ['t','f','T','F']
        exec "map ".key." <Plug>(easymotion-".key.")"
    endfor
    imap <C-f> <C-o>f
    imap <C-b> <C-o>T
    for key in ['w','b','e',"ge"]
        exec "map <unique> ".key." <Plug>(easymotion-iskeyword-".key.")"
        if strlen(key) != 1 || key < 'a' || key > 'z'
            continue
        endif
        exec "imap <unique> <Esc><C-".key."> <C-o><Plug>(easymotion-iskeyword-".key.")"
    endfor
    " let g:EasyMotion_startofline = 0
    for key in ['j','k']
        exec "map  <unique> <M-".key."> <Plug>(easymotion-".key.")"
        exec "imap <unique> <M-".key."> <C-o><Plug>(easymotion-".key.")"
    endfor
    map  <unique> <M-h> <Plug>(easymotion-Fl)
    map  <unique> <M-l> <Plug>(easymotion-fl)
    imap <unique> <M-h> <C-o><Plug>(easymotion-Fl)
    imap <unique> <M-l> <C-o><Plug>(easymotion-fl)
    "for key in ['t','T','f','F','w','b','e','W','B','E',"ge","gE"]
        "let act = key

        "if key ==# 'w' || key ==# 'b' || key ==# 'e' || key ==# 'ge'
            "let act = "iskeyword-".key
        "endif

        "exec "map <unique> ".key." <Plug>(easymotion-".act.")"

        "if strlen(key) != 1 || key < 'a' || key > 'z'
            "continue
        "else
            "exec "imap <unique> <Esc><C-".key."> <C-o><Plug>(easymotion-".act.")"
        "endif
    "endfor
endif " }}}
if PluginInstalled('vim-textobj-user') "{{{
    call textobj#user#plugin('php', {
        \   'code': {
        \       'pattern': ['<?php\>','?>'],
        \       'select-a': 'ap',
        \       'select-i': 'ip',
        \   }
        \ })
    call textobj#user#plugin('datetime', {
        \   'date': {
        \     'pattern': '\<\d\d\d\d-\d\d-\d\d\>',
        \     'select': ['ad', 'id'],
        \   },
        \   'time': {
        \     'pattern': '\<\d\d:\d\d:\d\d\>',
        \     'select': ['at', 'it'],
        \   },
        \ })
endif " }}}
if PluginInstalled('indentLine') "{{{
    nnoremap <unique> <Leader>il :IndentLinesToggle<CR>
    "let g:indentLine_enabled = 1
    let g:indentLine_showFirstIndentLevel = 1
    let g:indentLine_char = '│'
    let g:indentLine_first_char = '│'
    let g:indentLine_noConcealCursor = 1
    let g:indentLine_faster = 1
    let g:indentLine_fileTypeExclude = []
    let g:indentLine_fileType = ['c','cpp','python']
endif " }}}
if PluginInstalled('a.vim') "{{{
    nnoremap <unique> <M-a> :A<CR>
endif " }}}
if PluginInstalled('quicktask') "{{{
    let g:quicktask_snip_path= '~/snips'
    let g:quicktask_snip_default_filetype = 'markdown'
    nnoremap <unique> <Leader>ti Go# vim:ft=quicktask<Esc><C-o>
endif " }}}
if PluginInstalled('vimwiki') "{{{
    " use :hammer to have a quick preview of markdown
    " use pandoc to convert markdown to html in batch es
    " use grip to have a instant view of github flavoured markdown
    " use python-markdown extension to support table
    "let g:vimwiki_table_mappings = 1
    "let g:vimwiki_list_mappings = 0
    "let g:vimwiki_header_mode = 1
    let g:vimwiki_autowriteall = 1
    let g:vimwiki_folding = 'expr'
    autocmd FileType vimwiki setlocal foldlevel=1
    " followning <CR> nmap breaks jumping in error window
    "autocmd FileType vimwiki nmap <unique> <CR> <Plug>VimwikiFollowLink
    "autocmd FileType vimwiki nmap <unique> <BS> <Plug>VimwikiGoBackLink
    autocmd FileType vimwiki nmap <buffer> <C-n> <Plug>VimwikiNextLink
    autocmd FileType vimwiki nmap <buffer> <C-p> <Plug>VimwikiPrevLink
    nnoremap <unique> <Leader>vi :VimwikiGenerateLinks<CR>
    nnoremap <unique> <Leader>vg :VimwikiGoto<Space>
    nnoremap <unique> <Leader>vs :VimwikiSearch<Space>
    nnoremap <unique> <Leader>vb :VimwikiBacklinks<CR>
    nnoremap <unique> <Leader>vh :VimwikiAll2HTML<CR>
    nnoremap <unique> <Leader>vt :VimwikiTable<Space>
                "\| iunmap <buffer> <CR>

    "autocmd BufEnter * nmap <buffer> <BS> <Plug>VimwikiGoBackLink
    let g:vimwiki_dir_link = 'index'
    let g:vimwiki_ext2syntax = {'.md': 'markdown',}
    let g:vimwiki_list = [
        \ {'path': '~/vimwiki/markdown-main/', 'syntax': 'markdown', 'ext': '.md', 'path_html': '~/vimwiki/html/markdown-test/'},
        \ {'path': '~/vimwiki/main/', 'syntax': 'default', 'ext': '.wiki', 'path_html': '~/vimwiki/html/main/'},
        \ {'path': '~/vimwiki/research/', 'syntax': 'default', 'ext': '.wiki', 'path_html': '~/vimwiki/html/research/'},
        \ ]
    " dev workaround
    autocmd FileType vimwiki iunmap <buffer> <C-L><C-J>
    autocmd FileType vimwiki iunmap <buffer> <C-L><C-K>
    autocmd FileType vimwiki iunmap <buffer> <C-L><C-M>
    autocmd FileType vimwiki iunmap <buffer> <buffer> <C-D>
    autocmd FileType vimwiki iunmap <buffer> <buffer> <C-T>
    autocmd FileType vimwiki inoremap <buffer> <C-G><C-D> <C-O>:VimwikiListDecreaseLvl 0<CR>
    autocmd FileType vimwiki inoremap <buffer> <C-G><C-T> <C-O>:VimwikiListIncreaseLvl 0<CR>
    autocmd FileType vimwiki inoremap <buffer> <C-G><C-J> <C-O>:VimwikiListChangeMarker next i<CR>
    autocmd FileType vimwiki inoremap <buffer> <C-G><C-K> <C-O>:VimwikiListChangeMarker prev i<CR>
    autocmd FileType vimwiki inoremap <buffer> <C-G><C-M> <Esc>:call vimwiki#lst#toggle_list_item()<CR>
endif " }}}
if PluginInstalled('vim-geeknote') "{{{
    " let g:GeeknoteFormat = 'markdown'
    autocmd FileType geeknote setlocal foldlevel=1 nonumber
    autocmd FileType geeknote nmap <buffer> <M-o> <CR>
    nnoremap <unique> <Leader>ee :Geeknote<CR>
    nnoremap <unique> <Leader>en :GeeknoteCreateNote 
    nnoremap <unique> <Leader>ec :GeeknoteCreateNote 
    nnoremap <unique> <Leader>eb :GeeknoteCreateNotebook 
    nnoremap <unique> <Leader>et :GeeknoteCreateNotebook 
    nnoremap <unique> <Leader>es :GeeknoteSaveAsNote<CR>
    nnoremap <unique> <Leader>eu :GeeknoteSync<CR>
    nnoremap <unique> <Leader>er :GeeknoteSync<CR>
    nnoremap <unique> <Leader>ef :GeeknoteSearch 
endif " }}}
if PluginInstalled('simplenote.vim') "{{{
    let g:SimplenoteNoteFormat = "[%F][%T] %N %>%-20D"
    let g:SimplenoteStrftime = "%F %R"
    let g:SimplenoteSortOrder = "pinned,tags"
    let g:SimplenoteFileType = "markdown"
    " let g:SimplenoteListHeight = 30
endif "}}}
if PluginInstalled('vim-markdown') "{{{
    autocmd Filetype markdown nnoremap + :.HeaderIncrease<CR>
    autocmd Filetype markdown vnoremap + :HeaderIncrease<CR>gv
    autocmd Filetype markdown nnoremap _ :.HeaderDecrease<CR>
    autocmd Filetype markdown vnoremap _ :HeaderDecrease<CR>gv
endif "}}}
if PluginInstalled('riv.vim') "{{{
    " XXX: to see the list of options, check autoload/riv.vim. search
    " default.options
    let g:riv_global_leader = '<Leader>r'
endif " }}}
if PluginInstalled('VOoM') "{{{
    nnoremap <M-q> :exec 'VoomToggle '.&ft<CR>
endif " }}}
if PluginInstalled('YouCompleteMe') "{{{
    let g:ycm_global_ycm_extra_conf = '~/.vim/bundle/YouCompleteMe/cpp/ycm/.ycm_extra_conf.py'
    let g:ycm_always_populate_location_list = 1
    "let g:ycm_error_symbol = 'E'
    "let g:ycm_warning_symbol = 'W'
    "let g:ycm_enable_diagnostic_signs = 1
    let g:ycm_enable_diagnostic_highlighting = 0
    "let g:ycm_filetype_blacklist = {}
    " XXX: After YouCompleteMe prompt, it disables <C-u>, following line hacks
    " to work around this problem. But later I found it breaks insertion in block
    " visual mode. Now the only way I can think of is to map another key
    " binding to <C-u> :(
    "inoremap <Space> <Space><C-o><Esc>
endif " }}}
if PluginInstalled('ctrlp') "{{{
    let g:ctrlp_map = '<Leader><Leader>'
    "nnoremap <Leader>p :CtrlP<CR>
    nnoremap <unique> <Leader>pp :CtrlP<CR>
    nnoremap <unique> <Leader>pb :CtrlPBuffer<CR>
    nnoremap <unique> <Leader>pm :CtrlPMRU<CR>
    let g:ctrlp_working_path_mode = 2
    let g:ctrlp_custom_ignore = {
        \ 'dir':  '\.git$\|\.hg$\|\.svn$',
        \ 'file': '\.exe$\|\.so$\|\.dll$' }

    let g:ctrlp_user_command = {
        \ 'types': {
            \ 1: ['.git', 'cd %s && git ls-files . --cached --exclude-standard --others'],
            \ 2: ['.hg', 'hg --cwd %s locate -I .'],
        \ },
        \ 'fallback': 'find %s -type f'
    \ }
endif " }}}
if PluginInstalled('vim-fugitive') "{{{
    nnoremap <unique> <Leader>gs :Gstatus<CR>
    nnoremap <unique> <Leader>gc :Gcommit<CR>
    nnoremap <unique> <Leader>ga :Gcommit -a<CR>
    nnoremap <unique> <Leader>gp :Git push<CR>
    nnoremap <unique> <Leader>gd :Gdiff<CR>
endif " }}}
if PluginInstalled('delimitMate') "{{{
    "set matchpairs+=<:>
    let delimitMate_expand_space = 1
    let delimitMate_expand_cr = 1
    imap <unique> <C-g><C-g> <Plug>delimitMateS-Tab
    imap <unique> <C-g><C-e> <Plug>delimitMateJumpMany
    autocmd FileType tex let b:delimitMate_quotes = "\" ' ` $"
    autocmd FileType html,xml,jinja let b:delimitMate_matchpairs = '(:),{:},[:]'
    "imap <Space> <Plug>delimitMateSpace
    "autocmd FileType vimwiki let b:delimitMate_matchpairs=&matchpairs
    "autocmd FileType vimwiki let b:delimitMate_quotes = "\" ' ` * -"
    "autocmd FileType vimwiki let b:delimitMate_nesting_quotes = ['"','*','-',"'",'`']
    "autocmd FileType c,cpp,java let b:delimitMate_matchpairs=&matchpairs.",=:;"
endif " }}}
if PluginInstalled('matchit.zip') "{{{
    "let b:match_words = '<:>,\<if\>:\<else\>:\<endif\>'
endif " }}}
if PluginInstalled('vim-closetag') "{{{
    let g:closetag_filenames = "*.html,*.xhtml,*.phtml,*.j2,*.jinja,*.jinja2"
endif "}}}
if PluginInstalled('vim-powerline') "{{{
    let g:Powerline_symbols = 'fancy'
    let g:Powerline_stl_path_style = 'short'
endif " }}}
if PluginInstalled('tagbar') "{{{
    " following 3 lines make tagbar autofocus only when using :TagbarToggle,
    " but not when using :TagOpen
    let g:tagbar_autofocus = 1
    let g:tagbar_sort = 1
    nnoremap <unique> <silent> <M-p> :TagbarToggle<CR>
    "autocmd Filetype c,cpp,python :TagbarOpen
    autocmd Filetype tagbar nmap <buffer> <C-j> jp
    autocmd Filetype tagbar nmap <buffer> <C-k> kp
    " markdown supoort "{{{
    let g:tagbar_type_markdown = {
        \ 'ctagstype': 'markdown',
        \ 'ctagsbin' : '~/.vim/bundle/markdown2ctags/markdown2ctags.py',
        \ 'ctagsargs' : '-f - --sort=yes',
        \ 'kinds' : [
            \ 's:sections',
            \ 'i:images'
        \ ],
        \ 'sro' : '|',
        \ 'kind2scope' : {
            \ 's' : 'section',
        \ },
        \ 'sort': 0,
    \ } "}}}
    " rst supoort "{{{
    let g:tagbar_type_rst = {
        \ 'ctagstype': 'rst',
        \ 'ctagsbin' : '~/.vim/bundle/rst2ctags/rst2ctags.py',
        \ 'ctagsargs' : '-f - --sort=yes',
        \ 'kinds' : [
            \ 's:sections',
            \ 'i:images'
        \ ],
        \ 'sro' : '|',
        \ 'kind2scope' : {
            \ 's' : 'section',
        \ },
        \ 'sort': 0,
    \ } "}}}
endif " }}}
if PluginInstalled('nerdcommenter') "{{{
    let g:NERDSpaceDelims = 1
    " to work around the silly merging of #183
    let g:NERDCustomDelimiters = {
        \'python': {'left': '#'},
        \'haskell': {'left': '--'},
        \}
endif " }}}
if PluginInstalled('vim-commentary') "{{{
    xmap <Leader>c <Plug>Commentary
    omap <Leader>c <Plug>Commentary
    nmap <Leader>c <Plug>Commentary
    nmap <Leader>cc <Plug>CommentaryLine
    nmap <Leader>cg <Plug>ChangeCommentary
    nmap <Leader>cu <Plug>Commentary<Plug>Commentary
endif " }}}
if PluginInstalled('nerdtree') "{{{
    "nnoremap <leader>e :NERDTreeTabsOpen<CR>:NERDTreeSteppedClose<CR>:NERDTreeFind<CR>

    nnoremap <unique> <M-e> :NERDTree %:p:h<CR>
    autocmd FileType nerdtree nnoremap <buffer> <M-e> :NERDTreeClose<CR>

    let NERDTreeShowBookmarks=1
    let NERDTreeIgnore=['\.pyc', '\~$', '\.swo$', '\.swp$', '\.git', '\.hg', '\.svn', '\.bzr']
    "let NERDTreeChDirMode=2
    let NERDTreeQuitOnOpen=1
    let NERDTreeMouseMode=2
    let NERDTreeShowHidden=0
    let NERDTreeKeepTreeInNewTab=1
    let g:nerdtree_tabs_open_on_gui_startup=0
endif " }}}
if PluginInstalled('undotree') "{{{
    nnoremap <unique> <M-u> :UndotreeToggle<CR>
    let g:undotree_SetFocusWhenToggle=1
endif " }}}
if PluginInstalled('YankRing.vim') "{{{
    nnoremap <unique> <M-y> :YRShow<CR>
    "let g:yankring_replace_n_pkey = '<M-p>'
    "let g:yankring_replace_n_nkey = '<M-n>'
    "let g:yankring_zap_keys = '/ ?'
    "let g:yankring_manage_numbered_reg = 1
    "nnoremap <Leader>yc :YRClear<CR>
    "function! YRRunAfterMaps()
        "nnoremap Y   :<C-U>YRYankCount 'y$'<CR>
    "endfunction
endif " }}}
if PluginInstalled('tabular') "{{{
    " :Tabularize /:/l1r0
    " algin by :, insert 1 space to left, and 0 to right.default to l1r1
    "nnoremap <unique> <Leader>a& :Tabularize /&<CR>
    "vnoremap <unique> <Leader>a& :Tabularize /&<CR>
    "nnoremap <unique> <Leader>a= :Tabularize /=<CR>
    "vnoremap <unique> <Leader>a= :Tabularize /=<CR>
    "nnoremap <unique> <Leader>a: :Tabularize /:<CR>
    "vnoremap <unique> <Leader>a: :Tabularize /:<CR>
    "nnoremap <unique> <Leader>a:: :Tabularize /:\zs<CR>
    "vnoremap <unique> <Leader>a:: :Tabularize /:\zs<CR>
    "nnoremap <unique> <Leader>a, :Tabularize /,<CR>
    "vnoremap <unique> <Leader>a, :Tabularize /,<CR>
    "nnoremap <unique> <Leader>a<Bar> :Tabularize /<Bar><CR>
    "vnoremap <unique> <Leader>a<Bar> :Tabularize /<Bar><CR>
endif " }}}
if PluginInstalled('sessionman.vim') "{{{
    set sessionoptions=blank,buffers,curdir,folds,tabpages,winsize
    nnoremap <leader>sl :SessionList<CR>
    nnoremap <leader>ss :SessionSave<CR>
endif " }}}
if PluginInstalled('syntastic') "{{{
    nnoremap <unique> <Leader>kk :SyntasticCheck<CR>:Errors<CR>
endif " }}}
if has("cscope") "{{{
    function! LoadCscope() " {{{
        if filereadable("cscope.out")
            exec "silent cscope add cscope.out"
        endif
        if filereadable($CSCOPE_DB)
            exec "silent cscope add $CSCOPE_DB"
        endif
    endfunc " }}}
    function! MakeCscope() "{{{
        if !filereadable("cscope.files")
            let pattern = '*.' . expand('%:e')
            if pattern !=# '*.'
                exec "silent! !find -name '".pattern."' > cscope.files"
                exec "silent! !cscope -Rb"
            endif
        endif
        exec "silent! !cscope -Rb"
        call LoadCscope()
        redraw!
    endfunc "}}}
    " use both cscope and ctag for 'ctrl-]', ':ta', 'vim'
    set cscopetag
    " search cscope first, then ctags
    set csto=0
    " add cscope database
    set nocsverb
    set csverb
    call LoadCscope()

    nnoremap <unique> <Leader>pm :call MakeCscope()<CR>
    nnoremap <unique> <Leader>ph :cscope help<CR>

    " normal mode map for cscope
    nnoremap <unique> <Leader>ps :cscope find s <C-R>=expand("<cword>")<CR>
    nnoremap <unique> <Leader>pg :cscope find g <C-R>=expand("<cword>")<CR>
    nnoremap <unique> <Leader>pd :cscope find d <C-R>=expand("<cword>")<CR>
    nnoremap <unique> <Leader>pc :cscope find c <C-R>=expand("<cword>")<CR>
    nnoremap <unique> <Leader>pt :cscope find t <C-R>=expand("<cword>")<CR>
    nnoremap <unique> <Leader>pe :cscope find e <C-R>=expand("<cword>")<CR>
    nnoremap <unique> <Leader>pf :cscope find f <C-R>=expand("<cfile>")<CR>
    nnoremap <unique> <Leader>pi :cscope find i ^<C-R>=expand("<cfile>")<CR>$<CR>

    " visual mode map for cscope
    vnoremap <unique> <Leader>ps :<C-u>cscope find s <C-R>*<CR>
    vnoremap <unique> <Leader>pg :<C-u>cscope find g <C-R>*<CR>
    vnoremap <unique> <Leader>pd :<C-u>cscope find d <C-R>*<CR>
    vnoremap <unique> <Leader>pc :<C-u>cscope find c <C-R>*<CR>
    vnoremap <unique> <Leader>pt :<C-u>cscope find t <C-R>*<CR>
    vnoremap <unique> <Leader>pe :<C-u>cscope find e <C-R>*<CR>
    vnoremap <unique> <Leader>pf :<C-u>cscope find f <C-R>*<CR>
    vnoremap <unique> <Leader>pi :<C-u>cscope find i ^<C-R>*$<CR>
endif " }}}
" }}}

let s:vimrc_private = "$HOME/.vimrc-private"
if filereadable(glob( s:vimrc_private ))
    exec 'source '.s:vimrc_private
endif

" vim:ft=vim:fdm=marker
